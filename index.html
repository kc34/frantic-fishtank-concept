<canvas id="mainCanvas" width="1600" height="900"></canvas>
<script>
let Managers = {
	Position: {
		Component: function(x, y, width, height) {
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}
	},
	Rendering: {
		Component: function(drawFn) {
			this.drawFn = drawFn;
		},
		manage: function(entity) {
			entity.renderingComponent.drawFn(entity.positionComponent);
		}
	},
	Movement: {
		Component: function(dx, dy, gravity, drag) {
			this.dx = dx;
			this.dy = dy;
			this.gravity = gravity;
			this.drag = drag;
		},
		manage: function(entity) {
			if (!entity.movementComponent) return;
			entity.positionComponent.x += entity.movementComponent.dx * 0.016;
			entity.positionComponent.y += entity.movementComponent.dy * 0.016;

			if (entity.positionComponent.x - entity.positionComponent.width / 2 < 0 && entity.movementComponent.dx < 0) {
				entity.positionComponent.x = entity.positionComponent.width / 2;
				entity.movementComponent.dx *= -0.5;
			}
			if (entity.positionComponent.x + entity.positionComponent.width / 2 > 1600 && entity.movementComponent.dx > 0) {
				entity.positionComponent.x = 1600 - entity.positionComponent.width / 2;
				entity.movementComponent.dx *= -0.5;
			}
			if (entity.positionComponent.y - entity.positionComponent.height / 2 < 100 && entity.movementComponent.dy < 0) {
				entity.positionComponent.y = 100 + entity.positionComponent.height / 2;
				entity.movementComponent.dy *= -0.5;
			}
			if (entity.positionComponent.y + entity.positionComponent.height / 2 > 900 && entity.movementComponent.dy > 0) {
				entity.positionComponent.y = 900 - entity.positionComponent.height / 2;
				entity.movementComponent.dy *= -0.5;
			}

			if (entity.positionComponent.y + entity.positionComponent.height / 2 < 900) {
				entity.movementComponent.dy += entity.movementComponent.gravity * 0.016;
			}

			entity.movementComponent.dx *= Math.pow(1 - entity.movementComponent.drag, 0.016);
			entity.movementComponent.dy *= Math.pow(1 - entity.movementComponent.drag, 0.016);
		}
	},
	Overlap: {
		Component: function(overlapFn) {
			this.overlapFn = overlapFn;
		},
		manage: function(entity1, entity2) {
			if (!entity1.overlapComponent) return;
			if (!entity2.overlapComponent) return;
			let pc1 = entity1.positionComponent;
			let pc2 = entity2.positionComponent;
			if (pc1.x - pc1.width / 2 < pc2.x + pc2.width / 2 &&
					pc1.x + pc1.width / 2 > pc2.x - pc2.width / 2 &&
					pc1.y - pc1.height / 2 < pc2.y + pc2.height / 2 &&
					pc1.y + pc1.height / 2 > pc2.y - pc2.height / 2) {
				entity1.overlapComponent.overlapFn(entity1, entity2);
				entity2.overlapComponent.overlapFn(entity2, entity1);
			}
		}
	},
	Logic: {
		Component: function(logicFn) {
			this.logicFn = logicFn;
		},
		manage: function(entity, entities) {
			if (!entity.logicComponent) return;
			entity.logicComponent.logicFn(entity, entities);
		}
	}
}

let Food = function(x, y) {
	this.inactive = false;
	this.positionComponent =
		new Managers.Position.Component(x, y, 10, 10);
	this.renderingComponent =
		new Managers.Rendering.Component(function(positionComponent) {
			mainCtx.fillStyle = 'rgb(255, 255, 255)';
			mainCtx.fillRect(
					positionComponent.x - positionComponent.width / 2,
					positionComponent.y - positionComponent.height / 2,
					positionComponent.width, positionComponent.height);
		});
	this.movementComponent =
		new Managers.Movement.Component(0, 0, 50, 0);
	this.overlapComponent =
		new Managers.Overlap.Component(function(thisEntity, otherEntity) {
			if (otherEntity instanceof Fish) {
				if (thisEntity.inactive == false) {
					thisEntity.inactive = true;
					console.log('Food eaten');
				}
			}
		});
}


let Fish = function() {
	this.inactive = false;
	this.positionComponent =
		new Managers.Position.Component(Math.random() * 1600, 100, 40, 40);
	this.renderingComponent =
		new Managers.Rendering.Component(function(positionComponent) {
			mainCtx.fillStyle = 'rgb(255, 127, 0)';
			mainCtx.fillRect(
					positionComponent.x - positionComponent.width / 2,
					positionComponent.y - positionComponent.height / 2,
					positionComponent.width, positionComponent.height);
			mainCtx.strokeStyle = 'rgb(255, 0, 0)';
			mainCtx.strokeRect(
					positionComponent.x - positionComponent.width / 2,
					positionComponent.y - positionComponent.height / 2,
					positionComponent.width, positionComponent.height);
		});
	this.movementComponent =
		new Managers.Movement.Component(0, 1000, 0, .5);
	this.overlapComponent =
		new Managers.Overlap.Component(function(thisEntity, otherEntity) {
			if (otherEntity instanceof Food && thisEntity.logicComponent.hungerMeter > 1/3 && thisEntity.logicComponent.hungerMeter < 1) {
				console.log('Fish fed');
				thisEntity.logicComponent.hungerMeter = 0;
			}
		});
	this.logicComponent = // Probably break me into a dropper component and a chaser component?
		new Managers.Logic.Component(function(thisEntity, entities) {
			const timePassed = 16/1000;
			thisEntity.logicComponent.hungerMeter += timePassed / 30;

			if (thisEntity.logicComponent.hungerMeter < 2/3) {
				thisEntity.renderingComponent.drawFn = function(positionComponent) {
					mainCtx.fillStyle = 'rgb(255, 127, 0)';
					mainCtx.fillRect(
							positionComponent.x - positionComponent.width / 2,
							positionComponent.y - positionComponent.height / 2,
							positionComponent.width, positionComponent.height);
					mainCtx.strokeStyle = 'rgb(255, 0, 0)';
					mainCtx.strokeRect(
							positionComponent.x - positionComponent.width / 2,
							positionComponent.y - positionComponent.height / 2,
							positionComponent.width, positionComponent.height);
				}
			} else if (thisEntity.logicComponent.hungerMeter > 2/3 && thisEntity.logicComponent.hungerMeter <= 1) {
				thisEntity.renderingComponent.drawFn = function(positionComponent) {
					mainCtx.fillStyle = 'rgb(255, 255, 0)';
					mainCtx.fillRect(
							positionComponent.x - positionComponent.width / 2,
							positionComponent.y - positionComponent.height / 2,
							positionComponent.width, positionComponent.height);
					mainCtx.strokeStyle = 'rgb(255, 0, 0)';
					mainCtx.strokeRect(
							positionComponent.x - positionComponent.width / 2,
							positionComponent.y - positionComponent.height / 2,
							positionComponent.width, positionComponent.height);
				}
			} else if (thisEntity.logicComponent.hungerMeter > 1) {
				thisEntity.renderingComponent.drawFn = function(positionComponent) {
					mainCtx.fillStyle = 'rgb(127, 127, 127)';
					mainCtx.fillRect(
							positionComponent.x - positionComponent.width / 2,
							positionComponent.y - positionComponent.height / 2,
							positionComponent.width, positionComponent.height);
					mainCtx.strokeStyle = 'rgb(255, 0, 0)';
					mainCtx.strokeRect(
							positionComponent.x - positionComponent.width / 2,
							positionComponent.y - positionComponent.height / 2,
							positionComponent.width, positionComponent.height);
				}
				thisEntity.movementComponent.gravity = 50;
				return;
			}

			thisEntity.logicComponent.coinMeter += timePassed / 15;
	
			if (thisEntity.logicComponent.coinMeter > 1) {
				thisEntity.logicComponent.coinMeter = 0;
				entities.push(new Coin(thisEntity.positionComponent.x, thisEntity.positionComponent.y));
			}

			if (thisEntity.logicComponent.hungerMeter < 1/3) return;
			let food = entities.filter((entity) => entity instanceof Food);
			if (food.length == 0) return;
			let closestFood =
				     food.reduce((acc, food) => {
					     accDist = Math.abs(acc.positionComponent.x - thisEntity.positionComponent.x) + Math.abs(acc.positionComponent.y - thisEntity.positionComponent.y);
					     foodDist = Math.abs(food.positionComponent.x - thisEntity.positionComponent.x) + Math.abs(food.positionComponent.y - thisEntity.positionComponent.y);
					     if (accDist < foodDist) return acc;
					     return food;
				     });
			if (closestFood.positionComponent.x - closestFood.positionComponent.width / 2 > thisEntity.positionComponent.x + thisEntity.positionComponent.width / 2) {
				thisEntity.movementComponent.dx += 100 * 16/1000;
			}
			if (closestFood.positionComponent.x + closestFood.positionComponent.width / 2 < thisEntity.positionComponent.x - thisEntity.positionComponent.width / 2) {
				thisEntity.movementComponent.dx += -100 * 16/1000;
			}
			if (closestFood.positionComponent.y - closestFood.positionComponent.height / 2 > thisEntity.positionComponent.y + thisEntity.positionComponent.height / 2) {
				thisEntity.movementComponent.dy += 100 * 16/1000;
			}
			if (closestFood.positionComponent.y + closestFood.positionComponent.height / 2 < thisEntity.positionComponent.y - thisEntity.positionComponent.height / 2) {
				thisEntity.movementComponent.dy += -100 * 16/1000;
			}
		});
	this.logicComponent.hungerMeter = 0.5;
	this.logicComponent.coinMeter = 0.5;
}

let Coin = function(x, y) {
	this.inactive = false;
	this.positionComponent =
		new Managers.Position.Component(x, y, 20, 20);
	this.renderingComponent =
		new Managers.Rendering.Component(function(positionComponent) {
			mainCtx.fillStyle = 'rgb(255, 255, 0)';
			mainCtx.fillRect(
					positionComponent.x - positionComponent.width / 2,
					positionComponent.y - positionComponent.height / 2,
					positionComponent.width, positionComponent.height);
		});
	this.movementComponent =
		new Managers.Movement.Component(0, 0, 50, 0);
}

const mainCanvas = document.getElementById('mainCanvas');
const mainCtx = mainCanvas.getContext('2d');

let entities = [];
let game = {money:200};

let create = function() {
	entities.push({
		inactive: false,
		positionComponent: new Managers.Position.Component(800, 450, 1600, 900),
		renderingComponent: new Managers.Rendering.Component(function(positionComponent) {
			let n = 100;
			for (let i = 0; i < n; i++) {
				mainCtx.fillStyle = 'rgb(0, 0, ' + ((n - i) * 255 / n) + ')';
				mainCtx.fillRect(
					positionComponent.x - positionComponent.width / 2,
					i * positionComponent.height / n,
					positionComponent.width,
					positionComponent.height / n);
			}
			mainCtx.fillStyle = 'rgb(127, 127, 127)';
			mainCtx.fillRect(0, 0, positionComponent.width, 100);
			mainCtx.fillStyle = 'rgb(255, 127, 000)';
			mainCtx.fillRect(30, 30, 40, 40);
			mainCtx.font = "30px Arial"
			mainCtx.textAlign = 'center';
			mainCtx.textBaseline = 'middle';
			mainCtx.fillStyle = 'rgb(255, 255, 255)';
			mainCtx.fillText('$' + game.money, 800, 50);
		})
	});
}

let main = function() {
	entities.forEach((entity) => Managers.Rendering.manage(entity));
	entities.forEach((entity) => Managers.Movement.manage(entity));
	for (let i = 0; i < entities.length; i++) {
		for (let j = i + 1; j < entities.length; j++) {
			Managers.Overlap.manage(entities[i], entities[j]);
		}
	}
	entities.forEach((entity) => Managers.Logic.manage(entity, entities));

	// Placeholder at-rest deletion function
	entities.forEach((entity) => {
		if (entity instanceof Coin ||
				entity instanceof Food ||
				(entity instanceof Fish && entity.logicComponent.hungerMeter > 1)) {
			if (entity.positionComponent.y >= 900 - entity.positionComponent.height / 2 && Math.abs(entity.movementComponent.dy) < 1) {
				entity.inactive = true;
			}
		}
	});

	entities = entities.filter((entity) => !entity.inactive);

}

create();

setInterval(main, 16);

function clickHandler(event) {
	if (event.offsetY < 100) {
		entities.push(new Fish());
		return;
	}
	let activeCoins = entities.filter((entity) => ((entity instanceof Coin) && (entity.inactive == false)));
	let clickedCoinIdx = activeCoins.findIndex((coin) => {
		return (event.offsetX > coin.positionComponent.x - coin.positionComponent.width / 2 &&
				event.offsetX < coin.positionComponent.x + coin.positionComponent.width / 2 &&
				event.offsetY > coin.positionComponent.y - coin.positionComponent.height / 2 &&
				event.offsetY < coin.positionComponent.y + coin.positionComponent.height / 2);
	});
	if (clickedCoinIdx != -1) {
		game.money += 25;
		activeCoins[clickedCoinIdx].inactive = true;
		return;
	}
	if (game.money >= 5) {
		game.money -= 5;
		entities.push(new Food(event.offsetX, event.offsetY));
	}
}

mainCanvas.addEventListener('mousedown', clickHandler);
/*
	function main() {
		currentScene.display.forEach((i) => {
			i.drawFn();
		});
		for (let groupName in currentScene.physics.groups) {
			currentScene.physics.groups[groupName].forEach((i) => {
				i.x += i.dx * 16 / 1000;
				i.y += i.dy * 16 / 1000;
				i.dx *= Math.pow(0.5, 16/1000);
				i.dy *= Math.pow(0.5, 16/1000);
				i.dy += i.ddy * 16 / 1000;
			});
			currentScene.physics.groups[groupName].forEach((i) => {
				if (i.x - i.width / 2 < 0 && i.dx < 0) {
					i.x = i.width / 2;
					i.dx *= -0.5;
				}
				if (i.x + i.width / 2 > 1600 && i.dx > 0) {
					i.x = 1600 - i.width / 2;
					i.dx *= -0.5;
				}
				if (i.y - i.height / 2 < 100 && i.dy < 0) {
					i.y = 100 + i.height / 2;
					i.dy *= -0.5;
				}
				if (i.y + i.height / 2 > 900 && i.dy > 0) {
					i.y = 900 - i.height / 2;
					i.dy *= -0.5;
				}
			});
			currentScene.physics.groups[groupName].forEach((i) => {
				i.drawFn();
			});
		}
		update();
	}

	create();

	function clickHandler(event) {
		if (event.offsetY < 100) {
			if (currentScene.money >= 100) {
				currentScene.money -= 100;
				currentScene.fish.push(new Fish(currentScene));
			}
			return;
		}
		let clickedCoinIdx = currentScene.physics.groups.coins.findIndex((coin) => {
			return (event.offsetX > coin.x - coin.width / 2 &&
					event.offsetX < coin.x + coin.width / 2 &&
					event.offsetY > coin.y - coin.height / 2 &&
					event.offsetY < coin.y + coin.height / 2);
		});
		if (clickedCoinIdx != -1) {
			currentScene.money += 25;
			currentScene.physics.groups.coins.splice(clickedCoinIdx, 1);
			return;
		}
		if (currentScene.money >= 5) {
			currentScene.money -= 5;
			currentScene.physics.groups.food.push(new currentScene.physics.physicsBody({
				width: 10,
				height: 10,
				x: event.offsetX,
				y: event.offsetY,
				ddy: 50,
				drawFn: function(x, y) {
					mainCtx.fillStyle = 'rgb(255, 255, 255)';
					mainCtx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
				}
			}));
		}
	}

	mainCanvas.addEventListener('mousedown', clickHandler);


	setInterval(main, 16);
	*/
</script>
